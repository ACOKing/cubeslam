<!doctype html>
<html>
  <head>
    <meta charset='utf8'>
    <title>Verlet Simulator</title>
    <style>
      .sim, .hidden {display: none;}
      .sim.active {display: inline-block;}

      #colorSelectContainer {
        z-index:1000;
        display:none;
        position:absolute;
        top:50%;
        left:50%;
        margin-top:-240px;
        margin-left:-320px;
        width: 640px;
          height:480px;
      }

      #colorSelectArea {
        position:absolute;
        width:100px;
        height:100px;
        left: 450px;
        top:80px;
        border: 10px solid red;
        z-index:30;
      }

      #colorSelectCenter {
        position:absolute;
        display: block;
        left:50%;
        top:50%;
        margin-left:-5px;
        margin-top:-5px;
        width:10px;
        height:10px;
        border: 1px solid black; 
        border-radius: 5px 5px 5px 5px;
        z-index:31;
      }

      #marker {
        position:absolute;
        width:20px;
        height:20px;
        top:350px;
        background-color: #ff0000; 
        border-radius: 10px 10px 10px 10px;
        z-index:390;
      }

      #videoInput {
        /*display:none;
      */

          left:5px;
          margin-top: 15px;
         -webkit-transform: scale(-1,1);
         width: 640px;
         height:480px;
         border-radius: 8px 8px 8px 8px;

      }
    </style>
    
  </head>
  <body>
    <div id="colorSelectContainer">
      <div id="colorSelectArea">
        <div id="colorSelectCenter"></div> 
      </div>
      <div id="marker"></div>
      <video id="videoInput"></video>
    </div>
    <div class='sim' id='lobby'>
      <h1>Pong Realtime Multiplayer test</h1>
      <h2><button id='play'>Play</button></h2>
      <p>The purpose of this is making sure realtime synchronization between two peers is possible.</p>
      <p>It does this by using a deterministic simulation (in plain english, a simulation that runs the exact same way) on both peers. Then one of the peers (the first one to enter the room at the moment) is a <i>host</i> and the other is a <i>guest</i>. This is important as the host is the one that will solve any conflicts while te guest is simply a "dumb client" telling the host where it's paddle is at the moment.</p>
      <p>Whenever the simulation changes, like when an <i>attract force</i> has been added (when the host clicks on the canvas), the change is propagated to the guest which will replay from the frame of the change using those changes (and in the future, including any changes the guest has done in between).</p>
      <p>This has been tested with a latency of 100-250ms (stockholm-new york) without the feeling of any lag. Currently the only "hole" where the lag will be experienced is if the guest expects the ball to hit the paddle but it's paddle position hasn't been reported to the host when the ball would hit the paddle. Then the host would score even though the guest wouldn't agree. This can be worked around if the paddle position will use the same kind of "replay" at these occations so the host will be able to make a more educated guess.</p>
      <h2>Features</h2>
      <ul>
        <li><i>Time synchronization</i> – Whenever two peers are in the room they will attempt to synchronize their clocks so the game will start at the same time.</li>
        <li><i>Forces</i> – host can add an attraction force (colored green) by clicking on the stage which will curve the ball (it's actually really fun!)</li>
        <li><i>Verlet based simulation</i> – After playing around with a few different integrators the verlet based one seemed to be the easiest to implement as well as very stable, which is key to keeping the peers in sync.</li>
        <li><i>2D &amp; 3D</i> – The renderer is separate from the simulation, as such both 2d and 3d is been very simple to implement.</li>
        <li><i>Very simple scoring</i> – host gets a point if ball hits guests' wall, guest gets a point if the ball hits hosts' wall. both gets points if they keep the ball alive.</li>
      </ul>
      <h2>Issues</h2>
      <ul>
        <li><i>Rooms get full</i> – The room handling needs some love, it doesn't disconnect users properly sometimes which causes the room to be full. The workaround now is to start a new one.</li>
        <li><i>Design</i> – Not even considered.</li>
      </ul>
    </div>
    
    <div class='sim' id='game'>
      <canvas id="canv" width="320" height="480"></canvas>
      <form id="form">
        <!-- <button type="button" name="reset" value="1">Reset</button> -->
        <label>Alive <input type="number" step="1" name="aliveScore" value="0"></label>
        <label>Guest <input type="number" step="1" name="guestScore" value="0"></label>
        <label>Host  <input type="number" step="1" name="hostScore" value="0"></label>
        <label>Frame <input type="number" step="1" name="frame" value="0"></label>
        <label>Speed <input type="number" name="speed" value="0"></label>
        <!-- 
        <label>Wind <input type="number" name="wind" value="900"></label>
        <label>Gravity <input type="checkbox" name="gravity" checked></label>
         -->
        <label class='hidden'>Paused <input type="checkbox" name="paused"></label>
        <label class='hidden'>Reverse <input type="checkbox" name="reverse"></label>
      </form>
      <ul>
        <li>Waiting for player...</li>
        <li id='ful' class='hidden'>Room full</li>
        <li id='con' class='hidden'>Player connected</li>
        <li id='syn' class='hidden'>Synchronizing <span id='sync'>...</span></li>
        <li id='sta' class='hidden'>Starting in <span id='countdown'>5</span></li>
      </ul>
    </div>

    <script>
      var conferenceRoom = "{{.Room}}"
        , channelToken = "{{.ChannelToken}}";
      window.CHANNEL_HOST = '46.21.100.66';
    </script>
    <script src="/_ah/channel/jsapi"></script>
    <script src="javascript/libs/dat.gui.min.js" type="text/javascript"></script>
    <script src="javascript/libs/signals.min.js" type="text/javascript"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js" type="text/javascript"></script>
    <script src='http://mrdoob.github.com/three.js/build/three.min.js'></script>
    <script src='./build/build.js'></script>
    <script>
    (function() {

      var
        // Configuration:
        hostname = window.CHANNEL_HOST || window.location.hostname || 'localhost',
        websocketServer = "ws://"+hostname+":8000/",
      
        // For browser compatibility:
        PeerConnection = window.PeerConnection 
                      || window.RTCPeerConnection 
                      || window.mozPeerConnection 
                      || window.webkitRTCPeerConnection 
                      || window.webkitPeerConnection00;

      if (typeof(PeerConnection) === 'undefined') {
        console.error('Your browser does not support PeerConnection.');
        return;
      }

      var pc = new PeerConnection(null);

      if (typeof(pc.createDataChannel) !== 'undefined') {
        try {
          // This will throw when data channels is not implemented properly yet
          pc.createDataChannel('polyfill')

          // If we get this far you already have DataChannel support.
          return;
        } catch(e){
          // TODO verify the Error
        }
      }

      function DataChannel(peerConnection,label,dataChannelDict) {
        this.label = label;
        this.reliable = dataChannelDict && dataChannelDict.reliable;
        this._peerConnection = peerConnection;

        this._webSocket = new WebSocket(websocketServer);
        this._webSocket.onclose = function() {
          // Do something!
        }

        this.readyState = "connecting";

        this._webSocket.onopen = function() {
          this.readyState = "open";
          this._identify();
        }.bind(this);

        this._webSocket.onmessage = function(msg) {
          if (typeof this.onmessage == 'function') {
            this.onmessage(msg);
          }
        }.bind(this);
      };

      DataChannel.prototype._identify = function() {
        if (this._peerConnection === null) return false;

        function description2id(description) {
          var result = description.sdp.replace(/(\r\n|\n|\r)/gm, '\n')
          var re = new RegExp("o=.+");
          result = re.exec(result)
          return result[0]
        }

        if (this._peerConnection._localDescription && this._peerConnection._remoteDescription) {
          this.send('connect:' 
            + description2id(this._peerConnection._localDescription) + '_' + this.label + ':' 
            + description2id(this._peerConnection._remoteDescription) + '_' + this.label);
        }
      };

      DataChannel.prototype.close = function() {
        this._webSocket.close();
      };

      DataChannel.prototype.send = function(data, onErrorCallback) {
        if( this.readyState == 'open' )
          this._webSocket.send(data, onErrorCallback);
      };

      PeerConnection.prototype.createDataChannel = function(label, dataChannelDict) {
        var channel = new DataChannel(this,label,dataChannelDict);

        if (typeof(this._allDataChannels) == 'undefined') {
          this._allDataChannels = [];
        }
        this._allDataChannels.push(channel);

        return channel;
      }

      // Overwrite PeerConnection's description setters, to get ID:s for the websocket connections.

      var
        setLocalDescription = PeerConnection.prototype.setLocalDescription,
        setRemoteDescription = PeerConnection.prototype.setRemoteDescription;

      PeerConnection.prototype.setLocalDescription = function(description) {
        this._localDescription = description;
        if (typeof(this._allDataChannels) != 'undefined') {
          for (var i in this._allDataChannels) {
            this._allDataChannels[i]._identify();
          }
        }
        setLocalDescription.call(this, description);
      };

      PeerConnection.prototype.setRemoteDescription = function(description) {
        this._remoteDescription = description;
        if (typeof(this._allDataChannels) != 'undefined') {
          for (var i in this._allDataChannels) {
            this._allDataChannels[i]._identify();
          }
        };
        setRemoteDescription.call(this, description);
      };

    }());



    </script>
    <script> require('verlet-sim')() </script>
  </body>
</html>
